# -*- coding: utf-8 -*-
"""BITCOIN PREDICTION.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YfA0W02QiCh5koqPohkxM5s08ADw6SCb
"""

import numpy as np
import pandas as pd

df_bitcoin = pd.read_csv("/content/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv")

df_bitcoin.head()

df_bitcoin["Timestamp"] = pd.to_datetime(df_bitcoin["Timestamp"],unit="s")

df_bitcoin["Timestamp"]

df_bitcoin = df_bitcoin.set_index("Timestamp")

df_bitcoin

df_bitcoin['price'] = (df_bitcoin['High']+ df_bitcoin['Low'])/2

df_bitcoin

df_bitcoin = df_bitcoin.resample('6H').mean()
df_bitcoin

df_bitcoin = df_bitcoin.dropna()
df_bitcoin

df_bitcoin.isnull().values.any()

df_bitcoin.isna().values.any()

pred_days = 500
df_bitcoin_train= df_bitcoin['price'][:len(df_bitcoin['price'])-pred_days].values.reshape(-1,1)
df_bitcoin_test= df_bitcoin['price'][len(df_bitcoin['price'])-pred_days:].values.reshape(-1,1)

df_bitcoin_train.shape

df_bitcoin_test.shape

from sklearn.preprocessing import MinMaxScaler

scaler_train = MinMaxScaler(feature_range=(0, 1))
scaled_train = scaler_train.fit_transform(df_bitcoin_train)

scaler_test = MinMaxScaler(feature_range=(0, 1))
scaled_test = scaler_test.fit_transform(df_bitcoin_test)

def create_dataset(dataset, look_back=30):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

trainX, trainY = create_dataset(scaled_train)
testX, testY = create_dataset(scaled_test)

trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))
testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))

trainX.shape

testX.shape

pip install -q -U keras-tuner

import keras_tuner as kt

from keras.models import Sequential
from keras.layers import Dense,LSTM,Dropout

def model_builder(hp):
    model = Sequential()
    model.add(LSTM(hp.Int('input_unit',min_value=32,max_value=512,step=32), return_sequences=True, input_shape= ( trainX.shape[1], trainX.shape[2])))
    for i in range(hp.Int('n_layers', 1, 4)):
        model.add(LSTM(hp.Int(f'lstm_{i}_units',min_value=32,max_value=512,step=32),return_sequences=True))
    model.add(LSTM(hp.Int('layer_2_neurons',min_value=32,max_value=512,step=32)))
    model.add(Dropout(hp.Float('Dropout_rate',min_value=0,max_value=0.5,step=0.05)))
    model.add(Dense(30, activation=hp.Choice('dense_activation',values=['relu', 'sigmoid'],default='relu')))
    model.add(Dropout(hp.Float('Dropout_rate',min_value=0,max_value=0.5,step=0.05)))
    model.add(Dense(1, activation=hp.Choice('dense_activation',values=['relu', 'sigmoid'],default='relu')))
   
    model.compile(loss='mean_squared_error', optimizer='adam',metrics = ['mse'])
    
    return model
    
tuner = kt.RandomSearch(model_builder, objective="mse", max_trials = 3, executions_per_trial =1,directory = "./")

tuner.search(x=trainX, y=trainY, epochs = 150, batch_size =128, validation_data=(testX, testY), shuffle=False)

tuner.results_summary()

best_model = tuner.get_best_models(num_models=1)[0]

history = best_model.fit(x=trainX, y=trainY, epochs = 150, batch_size =128, validation_data=(testX, testY), shuffle=False, verbose=0)

import matplotlib.pyplot as plt 
import seaborn as sns

plt.plot(history.history['loss'], label='train')
plt.plot(history.history['val_loss'], label='test')
plt.legend()
plt.show()

predicted_BTC_price = best_model.predict(testX)

predicted_BTC_price = scaler_test.inverse_transform(predicted_BTC_price.reshape(-1, 1))

true = scaler_test.inverse_transform(testY.reshape(-1, 1))

plt.plot(predicted_BTC_price, label='predict')
plt.plot(true, label='true')
plt.legend()
plt.show()